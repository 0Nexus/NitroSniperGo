package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"github.com/bwmarrin/discordgo"
	"github.com/fatih/color"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/exec"
	"os/signal"
	"regexp"
	"strconv"
	"strings"
	"syscall"
	"time"
)

// Variables used for command line parameters
var (
	Token string
)

func init() {
	file, err := ioutil.ReadFile("token.json")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed read file: %s\n", err)
		os.Exit(1)
	}

	var f interface{}
	err = json.Unmarshal(file, &f)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to parse JSON: %s\n", err)
		os.Exit(1)
	}

	// Type-cast `f` to a map by means of type assertion.
	m := f.(map[string]interface{})
	fmt.Printf("Parsed data: %v\n", m)

	str := fmt.Sprintf("%v", m["token"])

	flag.StringVar(&Token, "t", str, "Token")
	flag.Parse()
}

func main() {
	fmt.Print("\033[2J")
	c := exec.Command("clear")

	c.Stdout = os.Stdout
	c.Run() // Create a new Discord session using the provided bot token.
	color.Red(`
‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÑ  ‚ñà‚ñà‚ñì  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñÑ   ‚ñí‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñÄ‚ñà‚ñà‚ñà  ‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÑ      ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñÑ    ‚ñà  ‚ñà‚ñà‚ñì ‚ñà‚ñà‚ñì‚ñà‚ñà‚ñà  ‚ñì‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñÄ‚ñà‚ñà‚ñà
‚ñí‚ñà‚ñà‚ñÄ ‚ñà‚ñà‚ñå‚ñì‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà    ‚ñí ‚ñí‚ñà‚ñà‚ñÄ ‚ñÄ‚ñà  ‚ñí‚ñà‚ñà‚ñí  ‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà ‚ñí ‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà‚ñÄ ‚ñà‚ñà‚ñå   ‚ñí‚ñà‚ñà    ‚ñí  ‚ñà‚ñà ‚ñÄ‚ñà   ‚ñà ‚ñì‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà‚ñë  ‚ñà‚ñà‚ñí‚ñì‚ñà   ‚ñÄ ‚ñì‚ñà‚ñà ‚ñí ‚ñà‚ñà‚ñí
‚ñë‚ñà‚ñà   ‚ñà‚ñå‚ñí‚ñà‚ñà‚ñí‚ñë ‚ñì‚ñà‚ñà‚ñÑ   ‚ñí‚ñì‚ñà    ‚ñÑ ‚ñí‚ñà‚ñà‚ñë  ‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà ‚ñë‚ñÑ‚ñà ‚ñí‚ñë‚ñà‚ñà   ‚ñà‚ñå   ‚ñë ‚ñì‚ñà‚ñà‚ñÑ   ‚ñì‚ñà‚ñà  ‚ñÄ‚ñà ‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà‚ñë ‚ñà‚ñà‚ñì‚ñí‚ñí‚ñà‚ñà‚ñà   ‚ñì‚ñà‚ñà ‚ñë‚ñÑ‚ñà ‚ñí
‚ñë‚ñì‚ñà‚ñÑ   ‚ñå‚ñë‚ñà‚ñà‚ñë  ‚ñí   ‚ñà‚ñà‚ñí‚ñí‚ñì‚ñì‚ñÑ ‚ñÑ‚ñà‚ñà‚ñí‚ñí‚ñà‚ñà   ‚ñà‚ñà‚ñë‚ñí‚ñà‚ñà‚ñÄ‚ñÄ‚ñà‚ñÑ  ‚ñë‚ñì‚ñà‚ñÑ   ‚ñå     ‚ñí   ‚ñà‚ñà‚ñí‚ñì‚ñà‚ñà‚ñí  ‚ñê‚ñå‚ñà‚ñà‚ñí‚ñë‚ñà‚ñà‚ñë‚ñí‚ñà‚ñà‚ñÑ‚ñà‚ñì‚ñí ‚ñí‚ñí‚ñì‚ñà  ‚ñÑ ‚ñí‚ñà‚ñà‚ñÄ‚ñÄ‚ñà‚ñÑ
‚ñë‚ñí‚ñà‚ñà‚ñà‚ñà‚ñì ‚ñë‚ñà‚ñà‚ñë‚ñí‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí ‚ñì‚ñà‚ñà‚ñà‚ñÄ ‚ñë‚ñë ‚ñà‚ñà‚ñà‚ñà‚ñì‚ñí‚ñë‚ñë‚ñà‚ñà‚ñì ‚ñí‚ñà‚ñà‚ñí‚ñë‚ñí‚ñà‚ñà‚ñà‚ñà‚ñì    ‚ñí‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñí‚ñí‚ñí‚ñà‚ñà‚ñë   ‚ñì‚ñà‚ñà‚ñë‚ñë‚ñà‚ñà‚ñë‚ñí‚ñà‚ñà‚ñí ‚ñë  ‚ñë‚ñë‚ñí‚ñà‚ñà‚ñà‚ñà‚ñí‚ñë‚ñà‚ñà‚ñì ‚ñí‚ñà‚ñà‚ñí
‚ñí‚ñí‚ñì  ‚ñí ‚ñë‚ñì  ‚ñí ‚ñí‚ñì‚ñí ‚ñí ‚ñë‚ñë ‚ñë‚ñí ‚ñí  ‚ñë‚ñë ‚ñí‚ñë‚ñí‚ñë‚ñí‚ñë ‚ñë ‚ñí‚ñì ‚ñë‚ñí‚ñì‚ñë ‚ñí‚ñí‚ñì  ‚ñí    ‚ñí ‚ñí‚ñì‚ñí ‚ñí ‚ñë‚ñë ‚ñí‚ñë   ‚ñí ‚ñí ‚ñë‚ñì  ‚ñí‚ñì‚ñí‚ñë ‚ñë  ‚ñë‚ñë‚ñë ‚ñí‚ñë ‚ñë‚ñë ‚ñí‚ñì ‚ñë‚ñí‚ñì‚ñë
‚ñë ‚ñí  ‚ñí  ‚ñí ‚ñë‚ñë ‚ñë‚ñí  ‚ñë ‚ñë  ‚ñë  ‚ñí     ‚ñë ‚ñí ‚ñí‚ñë   ‚ñë‚ñí ‚ñë ‚ñí‚ñë ‚ñë ‚ñí  ‚ñí    ‚ñë ‚ñë‚ñí  ‚ñë ‚ñë‚ñë ‚ñë‚ñë   ‚ñë ‚ñí‚ñë ‚ñí ‚ñë‚ñë‚ñí ‚ñë      ‚ñë ‚ñë  ‚ñë  ‚ñë‚ñí ‚ñë ‚ñí‚ñë
‚ñë ‚ñë  ‚ñë  ‚ñí ‚ñë‚ñë  ‚ñë  ‚ñë  ‚ñë        ‚ñë ‚ñë ‚ñë ‚ñí    ‚ñë‚ñë   ‚ñë  ‚ñë ‚ñë  ‚ñë    ‚ñë  ‚ñë  ‚ñë     ‚ñë   ‚ñë ‚ñë  ‚ñí ‚ñë‚ñë‚ñë          ‚ñë     ‚ñë‚ñë   ‚ñë
‚ñë     ‚ñë        ‚ñë  ‚ñë ‚ñë          ‚ñë ‚ñë     ‚ñë        ‚ñë             ‚ñë           ‚ñë  ‚ñë              ‚ñë  ‚ñë   ‚ñë
‚ñë                   ‚ñë                           ‚ñë
	`)
	dg, err := discordgo.New(Token)

	if err != nil {
		fmt.Println("error creating Discord session,", err)
		return
	}

	// Register the messageCreate func as a callback for MessageCreate events.
	dg.AddHandler(messageCreate)

	// Open a websocket connection to Discord and begin listening.
	err = dg.Open()
	if err != nil {
		fmt.Println("error opening connection,", err)
		return
	}

	// Wait here until CTRL-C or other term signal is received.
	t := time.Now()
	m := color.New(color.FgMagenta)
	color.Cyan("Sniping Discord Nitro on " + strconv.Itoa(len(dg.State.Guilds)) + " Servers üî´\n\n")

	m.Print(t.Format("15:04:05 "))
	fmt.Println("[+] Bot is ready")
	sc := make(chan os.Signal, 1)
	signal.Notify(sc, syscall.SIGINT, syscall.SIGTERM, os.Interrupt, os.Kill)
	<-sc

	// Cleanly close down the Discord session.
	dg.Close()
}

// This function will be called (due to AddHandler above) every time a new
// message is created on any channel that the autenticated bot has access to.
func messageCreate(s *discordgo.Session, m *discordgo.MessageCreate) {

	if strings.Contains(m.Content, "discordapp.com/gifts/") || strings.Contains(m.Content, "discord.gift/") {
		t := time.Now()

		re := regexp.MustCompile("(discordapp.com/gifts/|discord.gift/)([a-zA-Z0-9]+)")
		code := re.FindStringSubmatch(m.Content)
		var jsonStr = []byte(`{"channel_id":` + m.ChannelID + "}")

		if len(code[2]) != 16 {
			color.Red("[x] Invalid Code")

			return
		}

		req, err := http.NewRequest("POST", "https://discordapp.com/api/v6/entitlements/gift-codes/"+code[2]+"/redeem", bytes.NewBuffer(jsonStr))
		req.Header.Set("Content-Type", "application/json")

		req.Header.Set("authorization", Token)
		client := &http.Client{}
		resp, err := client.Do(req)
		t2 := time.Now()

		if err != nil {
			panic(err)
		}
		defer resp.Body.Close()
		bodyBytes, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			log.Fatal(err)
		}
		bodyString := string(bodyBytes)
		magenta := color.New(color.FgMagenta)
		magenta.Print(t.Format("15:04:05 "))
		color.Green("[-] Snipped code: " + code[2] + " by " + m.Author.String())
		magenta.Print(t2.Format("15:04:05 "))
		if strings.Contains(bodyString, "This gift has been redeemed already.") {
			color.Yellow("[-] Code has been already redeemed")
		}
		if strings.Contains(bodyString, "nitro") {
			color.Green("[+] Code applied")
		}
		if strings.Contains(bodyString, "Unknown Gift Code") {
			color.Red("[x] Invalid Code")
		}
	}

}
